<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Power for linear models of longitudinal data with applications to Alzheimer's Disease Phase II study design • longpower</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Power for linear models of longitudinal data with applications to Alzheimer's Disease Phase II study design">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">longpower</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.0.27</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/longpower.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/mcdonohue/longpower/" class="external-link">
    <span class="fab fa-github fa-lg"></span>

  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Power for linear models of longitudinal data
with applications to Alzheimer’s Disease Phase II study design</h1>
                        <h4 data-toc-skip class="author">Michael C.
Donohue</h4>
            
            <h4 data-toc-skip class="date">2024-09-04</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/mcdonohue/longpower/blob/master/vignettes/longpower.Rmd" class="external-link"><code>vignettes/longpower.Rmd</code></a></small>
      <div class="hidden name"><code>longpower.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>We will discuss power and sample size estimation for randomized
placebo controlled studies in which the primary inference is based on
the interaction of treatment and time in a linear mixed effects model
<span class="citation">(Laird and Ware 1982)</span>. We will demonstrate
how the sample size formulas of <span class="citation">Liu and Liang
(1997)</span> for marginal or model fit by generalized estimating
equation (GEE) <span class="citation">(Zeger and Liang 1986)</span> can
be adapted for mixed effects models. Finally, using mixed effects model
estimates based on data from the Alzheimer’s Disease Neuroimaging
Initiative (ADNI), we will give examples of sample size calculations for
models with and without baseline covariates which may help explain
heterogeneity in cognitive decline and improve power.</p>
</div>
<div class="section level2">
<h2 id="power-calculations">Power calculations<a class="anchor" aria-label="anchor" href="#power-calculations"></a>
</h2>
<div class="section level3">
<h3 id="exchangeable-correlation-and-random-intercept-models">Exchangeable correlation and random intercept models<a class="anchor" aria-label="anchor" href="#exchangeable-correlation-and-random-intercept-models"></a>
</h3>
<p>Suppose we wish to estimate the required sample size for inference
regarding the interaction of treatment and time in a longitudinal,
placebo controlled study. Such calculations are relatively
straightforward when the inference is based on a GEE model in which the
correlation structure is assumed to be “exchangeable.” An exchangeable
correlation structure specifies that all observations from within the
same cluster, or repeated measures on the same subject, are equally
correlated. This is exactly equivalent to a random effects model which
includes a random intercept for each cluster of correlated observations.
Sample sizes for study designs using these models can be calculated
using a simple formula such as that in <span class="citation">Diggle,
Liang, and Zeger (1994)</span>, page 29. The formula requires the number
visits, the interval between visits, the estimated model variance
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>σ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\sigma^2</annotation></semantics></math>),
the within subject correlation
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>),
and of course the usual sample size calculation inputs (power,
significance level, and effect size).</p>
<p>To translate the formula of <span class="citation">Diggle, Liang, and
Zeger (1994)</span> to the random effects setting, let us first consider
the details of the assumed error structure of the GEE framework. The GEE
model assumes that the response for subject
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">t_{ij}</annotation></semantics></math>,
denoted
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">Y_{ij}</annotation></semantics></math>,
is the group mean, dependent on time and treatment, plus an error term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">\varepsilon_{ij}</annotation></semantics></math>.
Or, borrowing notation from <span class="citation">Diggle, Liang, and
Zeger (1994)</span>, for group A:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>β</mi><mrow><mn>0</mn><mi>A</mi></mrow></msub><mo>+</mo><msub><mi>β</mi><mrow><mn>1</mn><mi>A</mi></mrow></msub><msub><mi>t</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>,</mo><mspace width="1.0em"></mspace><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>m</mi><mo>;</mo><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">
Y_{ij} = \beta_{0A} + \beta_{1A}t_{ij} + \varepsilon_{ij},\quad i=1,\ldots,m; j=1,\ldots,n.
</annotation></semantics></math> and similarly for Group B. The null
hypothesis is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>:</mo><mi>d</mi><mo>=</mo><msub><mi>β</mi><mrow><mn>1</mn><mi>A</mi></mrow></msub><mo>−</mo><msub><mi>β</mi><mrow><mn>1</mn><mi>B</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">H_0: d=\beta_{1A} - \beta_{1B} = 0</annotation></semantics></math>.
Under an exchangeable correlation structure
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>σ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathrm{var}(Y_{ij})=\mathrm{var}(\varepsilon_{ij})=\sigma^2</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>,</mo><msub><mi>Y</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>,</mo><msub><mi>ε</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\mathrm{corr}(Y_{ij},Y_{ik})=\mathrm{corr}(\varepsilon_{ij}, \varepsilon_{ik})=\rho</annotation></semantics></math>,
for all subjects,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
and time points
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j, k</annotation></semantics></math>.</p>
<p>In the mixed effects framework we can assume a random intercept model
which is equivalent to the GEE model with exchangeable correlation
structure. In this case we believe
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>α</mi><mi>i</mi></msub><mo>+</mo><msubsup><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow><mo>*</mo></msubsup></mrow><annotation encoding="application/x-tex">\varepsilon_{ij} = \alpha_i + \varepsilon_{ij}^*</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\alpha_i</annotation></semantics></math>
is the random intercept term shared by all observations and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow><mo>*</mo></msubsup><annotation encoding="application/x-tex">\varepsilon_{ij}^*</annotation></semantics></math>
are independent and identically distributed (iid) error terms. We see
that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow><mo>*</mo></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{var}(Y_{ij})=\mathrm{var}(\varepsilon_{ij})=\mathrm{var}(\alpha_i) + \mathrm{var}(\varepsilon_{ij}^*)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>,</mo><msub><mi>Y</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mi>i</mi></msub><mo>+</mo><msubsup><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow><mo>*</mo></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mi>i</mi></msub><mo>+</mo><msubsup><mi>ε</mi><mrow><mi>i</mi><mi>k</mi></mrow><mo>*</mo></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mi>/</mi><msup><mi>σ</mi><mn>2</mn></msup><mo>=</mo><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msup><mi>σ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathrm{corr}(Y_{ij},Y_{ik})=E[(\alpha_i + \varepsilon_{ij}^*)(\alpha_i + \varepsilon_{ik}^*)]/\sigma^2=\mathrm{var}(\alpha_i)/\sigma^2</annotation></semantics></math>.
The variance of the random intercept,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{var}(\alpha_i)</annotation></semantics></math>,
and the residual variance,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{var}(\varepsilon_{ij})</annotation></semantics></math>,
are easily obtainable from the output of mixed effects fitting software
so that one might fit a random effects model to pilot data to educate a
power calculation using the GEE formula of <span class="citation">Diggle, Liang, and Zeger (1994)</span>. Assuming equal
numbers in the placebo and active groups, a common visit schedule for
all subjects
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>t</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{ij} = t_{kj}</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">i,j,k</annotation></semantics></math>),
and a random intercept model; the number of subjects per group is:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mfrac><mrow><mn>2</mn><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>z</mi><mi>α</mi></msub><mo>+</mo><msub><mi>z</mi><mi>Q</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow><mo>*</mo></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>n</mi><msubsup><mi>s</mi><mi>x</mi><mn>2</mn></msubsup><msup><mi>d</mi><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">
m = \frac{2(z_\alpha + z_Q)^2(\mathrm{var}(\alpha_i) + \mathrm{var}(\varepsilon_{ij}^*))^2(1-\mathrm{var}(\alpha_i)/\sigma^2)}{ns_x^2d^2}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>z</mi><mi>p</mi></msub><annotation encoding="application/x-tex">z_p</annotation></semantics></math>
is the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>th
standard normal quantile,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">1-P</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
is the specified power, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>s</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><msup><mi>n</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mo>∑</mo><mi>j</mi></msub><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo>−</mo><mover><mi>x</mi><mo accent="true">‾</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">s_x^2=n^{-1}\sum_j(t_{j}-\bar x)^2</annotation></semantics></math>.</p>
</div>
<div class="section level3">
<h3 id="general-correlation-and-random-slope-models">General correlation and random slope models<a class="anchor" aria-label="anchor" href="#general-correlation-and-random-slope-models"></a>
</h3>
<p>The random intercept model is not equipped to handle variations in
the rate of change from subject to subject. In many diseases, such as
Alzheimer’s disease, the rate of improvement or decline will vary
greatly within the treatment group, regardless of treatment. This
variation can be modeled with a random slope term. That is, we assume:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>β</mi><mrow><mn>0</mn><mi>A</mi></mrow></msub><mo>+</mo><msub><mi>β</mi><mrow><mn>1</mn><mi>A</mi></mrow></msub><msub><mi>t</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>α</mi><mrow><mn>0</mn><mi>i</mi></mrow></msub><mo>+</mo><msub><mi>α</mi><mrow><mn>1</mn><mi>i</mi></mrow></msub><msub><mi>t</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msubsup><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow><mo>*</mo></msubsup><mo>,</mo></mrow><annotation encoding="application/x-tex">
Y_{ij} = \beta_{0A} + \beta_{1A}t_{ij} + \alpha_{0i} + \alpha_{1i}t_{ij} + \varepsilon_{ij}^*,
</annotation></semantics></math> where we use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow><mo>*</mo></msubsup><annotation encoding="application/x-tex">\varepsilon_{ij}^*</annotation></semantics></math>
again to denote iid error and reserve
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">\varepsilon_{ij}</annotation></semantics></math>
for possibly correlated error. If we derive the correlation structure of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>α</mi><mrow><mn>0</mn><mi>i</mi></mrow></msub><mo>+</mo><msub><mi>α</mi><mrow><mn>1</mn><mi>i</mi></mrow></msub><msub><mi>t</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msubsup><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow><mo>*</mo></msubsup></mrow><annotation encoding="application/x-tex">\varepsilon_{ij}=\alpha_{0i} + \alpha_{1i}t_{ij} + \varepsilon_{ij}^*</annotation></semantics></math>,
which is necessary in order to use GEE-based sample size formulas, we
find that we no longer have an exchangeable correlation structure. In
fact
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mrow><mn>0</mn><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msubsup><mi>t</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mrow><mn>1</mn><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>2</mn><msub><mi>t</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mrow><mn>0</mn><mi>i</mi></mrow></msub><mo>,</mo><msub><mi>α</mi><mrow><mn>1</mn><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow><mo>*</mo></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{var}(Y_{ij})=\mathrm{var}(\varepsilon_{ij})=\mathrm{var}(\alpha_{0i})+t_{ij}^2\mathrm{var}(\alpha_{1i}) + 2t_{ij}\mathrm{cov}(\alpha_{0i},\alpha_{1i}) +\mathrm{var}(\varepsilon_{ij}^*)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>,</mo><msub><mi>Y</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>,</mo><msub><mi>ε</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mrow><mn>0</mn><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>t</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>t</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mrow><mn>1</mn><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>t</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mrow><mn>0</mn><mi>i</mi></mrow></msub><mo>,</mo><msub><mi>α</mi><mrow><mn>1</mn><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{cov}(Y_{ij},Y_{ik})=\mathrm{cov}(\varepsilon_{ij},\varepsilon_{ik})=\mathrm{var}(\alpha_{0i})+t_{ij}t_{ik}\mathrm{var}(\alpha_{1i}) + (t_{ij}+t_{ik})\mathrm{cov}(\alpha_{0i},\alpha_{1i})</annotation></semantics></math>.
For the common visit schedule case, the covariance matrix for the vector
of correlated errors,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝛆</mi><mi>𝐢</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>ε</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">\mathbf{\varepsilon_i}=(\varepsilon_{i1},\ldots,\varepsilon_{in})'</annotation></semantics></math>,
is of the form: <span class="math display">$$
\Sigma = [(\mathrm{var}(\alpha_{0})+t_{j}t_{k}\mathrm{var}(\alpha_{1}) +
(t_{j}+t_{k})\mathrm{cov}(\alpha_{0},\alpha_{1}))]_{jk}+{\rm
diag}(\mathrm{var}(\varepsilon^*_j))
$$</span> With this specification of the covariance matrix, one can use
the sample size formula of <span class="citation">Liu and Liang
(1997)</span> for linear GEE models (page 941). (Warning: The formula
given on the bottom page 29 of <span class="citation">Diggle, Liang, and
Zeger (1994)</span> for general correlation matrices,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>,
is wrong).</p>
<p>The formula for linear models provided by <span class="citation">Liu
and Liang (1997)</span> is useful for testing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>:</mo><mrow><mi>𝛙</mi><mo mathvariant="bold">=</mo><mn>𝟎</mn></mrow></mrow><annotation encoding="application/x-tex">H_0: \mathbf{\psi=0}</annotation></semantics></math>
for any linear model of the form:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>𝐱</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>′</mi><mi>𝛙</mi><mo>+</mo><msub><mi>𝐳</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>′</mi><mi>𝛌</mi><mo>+</mo><msub><mi>ε</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">
Y_{ij} = \mathbf{x}_{ij}'\mathbf{\psi} + \mathbf{z}_{ij}'\mathbf{\lambda} + \varepsilon_{ij}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝛆</mi><mi>𝐢</mi></msub><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>𝟎</mn><mo>,</mo><msup><mi>σ</mi><mn>2</mn></msup><mi>R</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{\varepsilon_i}\sim N(\mathbf{0},\sigma^2R)</annotation></semantics></math>
and the covariates for individual
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐱</mi><mi>i</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mi>′</mi><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>𝐱</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mi>′</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>′</mi><mrow><mi>n</mi><mo>×</mo><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{x}_{i}=(\mathbf{x}_{i1}', \ldots, \mathbf{x}_{i1}')'_{n\times p}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐳</mi><mi>i</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐳</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mi>′</mi><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>𝐳</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mi>′</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>′</mi><mrow><mi>n</mi><mo>×</mo><mi>q</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{z}_{i}=(\mathbf{z}_{i1}', \ldots, \mathbf{z}_{i1}')'_{n\times q}</annotation></semantics></math>,
arise from a known discrete distribution. For our placebo controlled
longitudinal study, the fully specified model is of the form: <span class="math display">$$
Y_{ij}=\beta_0 + \beta_1\{{\rm Group}_{i}=A\} + \beta_2t_{ij} +
\beta_3t_{ij}\{{\rm Group}_{i}=A\}.
$$</span> That is, the parameter of interest for the interaction of
treatment and time is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo>=</mo><msub><mi>β</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">\psi = \beta_3</annotation></semantics></math>
and nuisance parameter is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝛌</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>β</mi><mn>0</mn></msub><mo>,</mo><msub><mi>β</mi><mn>1</mn></msub><mo>,</mo><msub><mi>β</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">\mathbf{\lambda} = (\beta_0,\beta_1,\beta_2)'</annotation></semantics></math>.
The covariates are distributed as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐱</mi><mi>i</mi></msub><mo>=</mo><mi>𝐭</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>t</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}_{i} = \mathbf{t}= (t_1, \ldots, t_n)'</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐳</mi><mi>j</mi></msub><mo>=</mo><msub><mrow><mo stretchy="true" form="prefix">[</mo><mn>𝟏</mn><mspace width="0.167em"></mspace><mn>𝟏</mn><mspace width="0.167em"></mspace><mi>𝐭</mi><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mi>n</mi><mo>×</mo><mn>3</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{z}_j = [\mathbf{1}\, \mathbf{1}\, \mathbf{t}]_{n\times3}</annotation></semantics></math>
with probability 1/2 (Group A); and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐱</mi><mi>i</mi></msub><mo>=</mo><mn>𝟎</mn></mrow><annotation encoding="application/x-tex">\mathbf{x}_{i} = \mathbf{0}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐳</mi><mi>j</mi></msub><mo>=</mo><msub><mrow><mo stretchy="true" form="prefix">[</mo><mn>𝟏</mn><mspace width="0.167em"></mspace><mn>𝟎</mn><mspace width="0.167em"></mspace><mi>𝐭</mi><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mi>n</mi><mo>×</mo><mn>3</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{z}_j = [\mathbf{1}\, \mathbf{0}\, \mathbf{t}]_{n\times3}</annotation></semantics></math>
with probability 1/2 (Group B).</p>
<p>The Liu and Liang’s formula for linear models can be coded In R
as:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/mcdonohue/longpower" class="external-link">longpower</a></span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">liu.liang.linear.power</span></span></code></pre></div>
<pre><code>function (N = NULL, delta = NULL, u = NULL, v = NULL, sigma2 = 1, 
    R = NULL, R.list = NULL, sig.level = 0.05, power = NULL, 
    Pi = rep(1/length(u), length(u)), alternative = c("two.sided", 
        "one.sided"), tol = .Machine$double.eps^2) 
{
    if (sum(sapply(list(N, delta, sigma2, power, sig.level), 
        is.null)) != 1) 
        stop("exactly one of 'N', 'sigma2', 'delta', 'power', and 'sig.level' must be NULL")
    if (!is.null(sig.level) &amp;&amp; !is.numeric(sig.level) || any(0 &gt; 
        sig.level | sig.level &gt; 1)) 
        stop("'sig.level' must be numeric in [0, 1]")
    alternative &lt;- match.arg(alternative)
    if (sum(c(!is.null(R), !is.null(R.list))) != 1) 
        stop("Exactly one of R or R.list must be specified.")
    if (sum(Pi) != 1) 
        stop("Pi must sum to 1.")
    if (!is.null(R)) {
        R.list &lt;- lapply(1:length(u), function(i) R)
    }
    Rinv &lt;- lapply(1:length(R.list), function(i) {
        R &lt;- R.list[[i]]
        if (is.null(dim(R)) &amp; length(R) == 1 &amp; length(u[[i]]) &gt; 
            1) {
            R &lt;- matrix(R, length(u[[i]]), length(u[[i]])) + 
                diag(1 - R, length(u[[i]]))
        }
        else if (is.null(dim(R)) &amp; length(R) == 1 &amp; length(u[[i]]) == 
            1) {
            R &lt;- matrix(R, length(u[[i]]), length(u[[i]]))
        }
        return(solve(R))
    })
    n.body &lt;- quote({
        Ipl &lt;- 0
        for (i in 1:length(u)) Ipl &lt;- Ipl + Pi[i] * t(u[[i]]) %*% 
            Rinv[[i]] %*% v[[i]]
        Ipl &lt;- Ipl/sigma2
        Ill &lt;- 0
        for (i in 1:length(u)) Ill &lt;- Ill + Pi[i] * t(v[[i]]) %*% 
            Rinv[[i]] %*% v[[i]]
        Illinv &lt;- solve(Ill/sigma2)
        Sigma1 &lt;- 0
        for (i in 1:length(u)) Sigma1 &lt;- Sigma1 + Pi[i] * (t(u[[i]]) - 
            Ipl %*% Illinv %*% t(v[[i]])) %*% Rinv[[i]] %*% (u[[i]] - 
            v[[i]] %*% Illinv %*% t(Ipl))
        Sigma1 &lt;- Sigma1/sigma2
        (qnorm(1 - ifelse(alternative == "two.sided", sig.level/2, 
            sig.level)) + qnorm(power))^2/(delta %*% Sigma1 %*% 
            delta)[1, 1]
    })
    if (is.null(N)) 
        N &lt;- eval(n.body)
    else if (is.null(sig.level)) 
        sig.level &lt;- uniroot(function(sig.level) eval(n.body) - 
            N, c(1e-10, 1 - 1e-10), tol = tol, extendInt = "yes")$root
    else if (is.null(power)) 
        power &lt;- uniroot(function(power) eval(n.body) - N, c(0.001, 
            1 - 1e-10), tol = tol, extendInt = "yes")$root
    else if (is.null(delta)) 
        delta &lt;- uniroot(function(delta) eval(n.body) - N, sqrt(sigma2) * 
            c(1e-07, 1e+07), tol = tol, extendInt = "downX")$root
    else if (is.null(sigma2)) 
        sigma2 &lt;- uniroot(function(sigma2) eval(n.body) - N, 
            delta * c(1e-07, 1e+07), tol = tol, extendInt = "yes")$root
    else stop("internal error", domain = NA)
    METHOD &lt;- "Longitudinal linear model power calculation (Liu &amp; Liang, 1997)"
    structure(list(N = N, n = N * Pi, delta = delta, sigma2 = sigma2, 
        sig.level = sig.level, power = power, alternative = alternative, 
        R = R, note = "N is *total* sample size and n is sample size in *each* group", 
        method = METHOD), class = "power.longtest")
}
&lt;bytecode: 0x55ce84495038&gt;
&lt;environment: namespace:longpower&gt;</code></pre>
<p>The parameters include <code>d</code>, the effect size (possibly
vector); <code>u</code>, the list of covariate vectors or matrices
associated with the parameter of interest; <code>v</code>, the
respective list of covariate vectors or matrices associated with the
nuisance parameter; <code>sigma2</code>, the error variance;
<code>R</code>, the correlation structure; and <code>Pi</code> the
proportion of covariates of each type (<code>u</code>, <code>v</code>,
and <code>Pi</code> are expected to be the same length and sorted with
respect to each other).</p>
<p>For example, we can reproduce the table of sample sizes (per group)
on page 29 of <span class="citation">Diggle, Liang, and Zeger
(1994)</span> for the given exchangeable correlations with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐭</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>5</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">\mathbf{t} = (0,2,5)'</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.05</mn></mrow><annotation encoding="application/x-tex">\alpha=0.05</annotation></semantics></math>,
power=0.80, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">d=0.5</annotation></semantics></math>
via the <code><a href="../reference/diggle.linear.power.html">diggle.linear.power()</a></code> function:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n</span> <span class="op">=</span> <span class="fl">3</span> <span class="co"># visits</span></span>
<span><span class="va">t</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">2</span>,<span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">rho</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">0.5</span>, <span class="fl">0.8</span><span class="op">)</span></span>
<span><span class="va">sigma2</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">100</span>, <span class="fl">200</span>, <span class="fl">300</span><span class="op">)</span></span>
<span><span class="va">tab.diggle</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/outer.html" class="external-link">outer</a></span><span class="op">(</span><span class="va">rho</span>, <span class="va">sigma2</span>, </span>
<span>      <span class="fu"><a href="https://rdrr.io/r/base/Vectorize.html" class="external-link">Vectorize</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">rho</span>, <span class="va">sigma2</span><span class="op">)</span><span class="op">{</span></span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">ceiling</a></span><span class="op">(</span><span class="fu"><a href="../reference/diggle.linear.power.html">diggle.linear.power</a></span><span class="op">(</span></span>
<span>          d<span class="op">=</span><span class="fl">0.5</span>,</span>
<span>          t<span class="op">=</span><span class="va">t</span>,</span>
<span>          sigma2<span class="op">=</span><span class="va">sigma2</span>,</span>
<span>          R<span class="op">=</span><span class="va">rho</span>,</span>
<span>          alternative<span class="op">=</span><span class="st">"one.sided"</span>,</span>
<span>          power<span class="op">=</span><span class="fl">0.80</span><span class="op">)</span><span class="op">$</span><span class="va">n</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">}</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">tab.diggle</span><span class="op">)</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">"sigma2 ="</span>, <span class="va">sigma2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">rownames</a></span><span class="op">(</span><span class="va">tab.diggle</span><span class="op">)</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">"rho ="</span>, <span class="va">rho</span><span class="op">)</span></span>
<span><span class="va">tab.diggle</span></span></code></pre></div>
<pre><code>          sigma2 = 100 sigma2 = 200 sigma2 = 300
rho = 0.2          313          625          938
rho = 0.5          196          391          586
rho = 0.8           79          157          235</code></pre>
<p>or via the <code><a href="../reference/liu.liang.linear.power.html">liu.liang.linear.power()</a></code> function:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>u1 <span class="op">=</span> <span class="va">t</span>, u2 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>,<span class="va">n</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">v</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>v1 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="va">t</span><span class="op">)</span>,</span>
<span>         v2 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="va">t</span><span class="op">)</span><span class="op">)</span>         </span>
<span><span class="va">tab.ll</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/outer.html" class="external-link">outer</a></span><span class="op">(</span><span class="va">rho</span>, <span class="va">sigma2</span>, </span>
<span>      <span class="fu"><a href="https://rdrr.io/r/base/Vectorize.html" class="external-link">Vectorize</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">rho</span>, <span class="va">sigma2</span><span class="op">)</span><span class="op">{</span></span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">ceiling</a></span><span class="op">(</span><span class="fu"><a href="../reference/liu.liang.linear.power.html">liu.liang.linear.power</a></span><span class="op">(</span></span>
<span>          delta<span class="op">=</span><span class="fl">0.5</span>, u<span class="op">=</span><span class="va">u</span>, v<span class="op">=</span><span class="va">v</span>,</span>
<span>          sigma2<span class="op">=</span><span class="va">sigma2</span>,</span>
<span>          R<span class="op">=</span><span class="va">rho</span>, alternative<span class="op">=</span><span class="st">"one.sided"</span>,</span>
<span>          power<span class="op">=</span><span class="fl">0.80</span><span class="op">)</span><span class="op">$</span><span class="va">n</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">}</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">tab.ll</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">"sigma2 ="</span>, <span class="va">sigma2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">rownames</a></span><span class="op">(</span><span class="va">tab.ll</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">"rho ="</span>, <span class="va">rho</span><span class="op">)</span></span>
<span><span class="va">tab.ll</span></span></code></pre></div>
<pre><code>          sigma2 = 100 sigma2 = 200 sigma2 = 300
rho = 0.2          313          625          938
rho = 0.5          196          391          586
rho = 0.8           79          157          235</code></pre>
<p>As a second example, consider an Alzheimer’s disease trial in which
assessments are taken every three months for 18 months (7 visits). We
assume an smallest detectable effect size of 1.5 points on the cognitive
portion of the Alzheimer’s Disease Assessment Scale (ADAS-Cog). This is
a 70 point scale with great variability among sick individuals. We
assume the random intercept to have a variance of 55, the random slope
to have a variance of 24, and a residual variance of 10. The correlation
between random slope term and random intercept term is 0.8. We can
estimate the necessary sample size by first generating the correlation
structure. Since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>=</mo><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varepsilon = \mathrm{var}(Y_{ij})</annotation></semantics></math>
is not constant over time in this model, we fix <code>sigma2=1</code>
and set <code>R</code> equal to the covariance matrix for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝛆</mi><mi>𝐢</mi></msub><annotation encoding="application/x-tex">\mathbf{\varepsilon_i}</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># var of random intercept</span></span>
<span><span class="va">sig2.i</span> <span class="op">&lt;-</span> <span class="fl">55</span></span>
<span><span class="co"># var of random slope</span></span>
<span><span class="va">sig2.s</span> <span class="op">&lt;-</span> <span class="fl">24</span></span>
<span><span class="co"># residual var</span></span>
<span><span class="va">sig2.e</span> <span class="op">&lt;-</span> <span class="fl">10</span></span>
<span><span class="co"># covariance of slope and intercep</span></span>
<span><span class="va">cov.s.i</span> <span class="op">&lt;-</span> <span class="fl">0.8</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="va">sig2.i</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="va">sig2.s</span><span class="op">)</span></span>
<span></span>
<span><span class="va">cov.t</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">t1</span>, <span class="va">t2</span>, <span class="va">sig2.i</span>, <span class="va">sig2.s</span>, <span class="va">cov.s.i</span><span class="op">)</span><span class="op">{</span></span>
<span>        <span class="va">sig2.i</span> <span class="op">+</span> <span class="va">t1</span><span class="op">*</span><span class="va">t2</span><span class="op">*</span><span class="va">sig2.s</span> <span class="op">+</span> <span class="op">(</span><span class="va">t1</span><span class="op">+</span><span class="va">t2</span><span class="op">)</span><span class="op">*</span><span class="va">cov.s.i</span> </span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">t</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1.5</span>,<span class="fl">0.25</span><span class="op">)</span></span>
<span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">t</span><span class="op">)</span></span>
<span><span class="va">R</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/outer.html" class="external-link">outer</a></span><span class="op">(</span><span class="va">t</span>, <span class="va">t</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span>,<span class="va">y</span><span class="op">)</span><span class="op">{</span><span class="fu">cov.t</span><span class="op">(</span><span class="va">x</span>,<span class="va">y</span>, <span class="va">sig2.i</span>, <span class="va">sig2.s</span>, <span class="va">cov.s.i</span><span class="op">)</span><span class="op">}</span><span class="op">)</span></span>
<span><span class="va">R</span> <span class="op">&lt;-</span> <span class="va">R</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="va">sig2.e</span>, <span class="va">n</span>, <span class="va">n</span><span class="op">)</span></span>
<span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>u1 <span class="op">=</span> <span class="va">t</span>, u2 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>,<span class="va">n</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">v</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>v1 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="va">t</span><span class="op">)</span>,</span>
<span>         v2 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="va">t</span><span class="op">)</span><span class="op">)</span>         </span>
<span></span>
<span><span class="fu"><a href="../reference/liu.liang.linear.power.html">liu.liang.linear.power</a></span><span class="op">(</span>d<span class="op">=</span><span class="fl">1.5</span>, u<span class="op">=</span><span class="va">u</span>, v<span class="op">=</span><span class="va">v</span>, R<span class="op">=</span><span class="va">R</span>, sig.level<span class="op">=</span><span class="fl">0.05</span>, power<span class="op">=</span><span class="fl">0.80</span><span class="op">)</span></span></code></pre></div>
<pre><code>
     Longitudinal linear model power calculation (Liu &amp; Liang, 1997) 

              N = 414.6202
              n = 207.3101, 207.3101
          delta = 1.5
         sigma2 = 1
      sig.level = 0.05
          power = 0.8
    alternative = two.sided

 NOTE: N is *total* sample size and n is sample size in *each* group 

 R:
         [,1]      [,2]      [,3]      [,4]      [,5]     [,6]      [,7]
[1,] 65.00000  62.26636  69.53272  76.79908  84.06544  91.3318  98.59817
[2,] 62.26636  81.03272  79.79908  88.56544  97.33180 106.0982 114.86453
[3,] 69.53272  79.79908 100.06544 100.33180 110.59817 120.8645 131.13089
[4,] 76.79908  88.56544 100.33180 122.09817 123.86453 135.6309 147.39725
[5,] 84.06544  97.33180 110.59817 123.86453 147.13089 150.3972 163.66361
[6,] 91.33180 106.09817 120.86453 135.63089 150.39725 175.1636 179.92997
[7,] 98.59817 114.86453 131.13089 147.39725 163.66361 179.9300 206.19633</code></pre>
<p>So the study would require about 207 subjects per arm to achieve 80%
power, with a two-tailed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.05</mn></mrow><annotation encoding="application/x-tex">\alpha=0.05</annotation></semantics></math>.</p>
<p>The simple formula provided in <span class="citation">Diggle, Liang,
and Zeger (1994)</span> suggests the required number of subjects can be
found by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>z</mi><mi>α</mi></msub><mo>+</mo><msub><mi>z</mi><mi>Q</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mi>ξ</mi><mi>/</mi><msup><mi>d</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2(z_\alpha+z_Q)^2\xi/d^2</annotation></semantics></math>,
where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ξ</mi><mtext mathvariant="normal">WRONG</mtext></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mi>…</mi></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>t</mi><mn>1</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>…</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>t</mi><mi>n</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>t</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>t</mi><mi>n</mi></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
\xi_\textrm{WRONG}=
  \left(\begin{array}{cc}
    0 &amp; 1\\ 
    \end{array}\right)
\left(\begin{array}{ccc}
1 &amp; \ldots &amp; 1 \\
t_1 &amp; \ldots &amp; t_n \\
\end{array}\right)R^{-1}
\left(\begin{array}{ccc}
1 &amp; t_1 \\
\vdots &amp; \vdots\\
1 &amp; t_n
\end{array}\right)
  \left(\begin{array}{c}
    0 \\ 1
    \end{array}\right).
</annotation></semantics></math> Executing this for our Alzheimer’s
example, we get a sample size of:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="fl">1</span>,<span class="va">t</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/solve-methods.html" class="external-link">solve</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fl">1</span>,<span class="va">t</span><span class="op">)</span><span class="op">)</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span></span>
<span><span class="va">x</span><span class="op">*</span><span class="fl">2</span><span class="op">*</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">qnorm</a></span><span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="fl">0.05</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">qnorm</a></span><span class="op">(</span><span class="fl">0.80</span><span class="op">)</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">/</span><span class="fl">1.5</span><span class="op">^</span><span class="fl">2</span></span></code></pre></div>
<pre><code>[1] 0.3592744</code></pre>
<p>which is clearly wrong. In fact, there is a typo in <span class="citation">Diggle, Liang, and Zeger (1994)</span>. The correct
formula for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ξ</mi><annotation encoding="application/x-tex">\xi</annotation></semantics></math>
is:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ξ</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><msup><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>t</mi><mn>1</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>t</mi><mn>2</mn></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>σ</mi><mn>2</mn></msup><mi>R</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>t</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>t</mi><mi>m</mi></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq:diggle3}
\xi = 
  \left(\begin{array}{cc}
    0 &amp; 1\\ 
    \end{array}\right)
  \left[
  \left(\begin{array}{ccc}
    1 &amp; \cdots &amp; 1 \\
    t_1 &amp; \cdots &amp; t_2\end{array}\right)
  (\sigma^2R)^{-1}
  \left(\begin{array}{cc}
    1 &amp; t_1 \\
    \vdots &amp; \vdots \\
    1 &amp; t_m\end{array}\right)\right]^{-1}
  \left(\begin{array}{c}
    0 \\ 1
    \end{array}\right).
\end{equation}</annotation></semantics></math></p>
<p>Applying the correct formula, we get</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/solve-methods.html" class="external-link">solve</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="fl">1</span>,<span class="va">t</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/solve-methods.html" class="external-link">solve</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fl">1</span>,<span class="va">t</span><span class="op">)</span><span class="op">)</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span></span>
<span><span class="va">x</span><span class="op">*</span><span class="fl">2</span><span class="op">*</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">qnorm</a></span><span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="fl">0.05</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">qnorm</a></span><span class="op">(</span><span class="fl">0.80</span><span class="op">)</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">/</span><span class="fl">1.5</span><span class="op">^</span><span class="fl">2</span></span></code></pre></div>
<pre><code>[1] 207.3101</code></pre>
<p>Similarly, using <span class="citation">Liu and Liang (1997)</span>,
we attempt to derive the correct closed form formula for this specific
linear model. The required sample size per group is given as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mi>ν</mi><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ψ</mi><mn>1</mn></msub><mi>′</mi><msub><mover><mi>Σ</mi><mo accent="true">̃</mo></mover><mn>1</mn></msub><msub><mi>ψ</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
m = \nu/(\psi_1'\tilde\Sigma_1\psi_1)
</annotation></semantics></math> where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>Σ</mi><mo accent="true">̃</mo></mover><mn>1</mn></msub><mo>=</mo><msup><mi>σ</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>π</mi><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐮</mi><mi>l</mi></msub><mi>′</mi><mo>−</mo><msub><mi>I</mi><mrow><mi>ψ</mi><mi>λ</mi></mrow></msub><msubsup><mi>I</mi><mrow><mi>λ</mi><mi>λ</mi></mrow><mo>−</mo></msubsup><mn>1</mn><msub><mi>𝐯</mi><mi>l</mi></msub><mi>′</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐮</mi><mi>l</mi></msub><mi>′</mi><mo>−</mo><msub><mi>𝐯</mi><mi>l</mi></msub><msubsup><mi>I</mi><mrow><mi>λ</mi><mi>λ</mi></mrow><mo>−</mo></msubsup><mn>1</mn><msub><mi>I</mi><mrow><mi>ψ</mi><mi>λ</mi></mrow></msub><mi>′</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\tilde\Sigma_1 =\sigma^{-2}\sum_{l=1}^m\pi_l
(\mathbf{u}_l'-I_{\psi\lambda}I_{\lambda\lambda}^-1\mathbf{v}_l')R^{-1}
(\mathbf{u}_l'-\mathbf{v}_lI_{\lambda\lambda}^-1I_{\psi\lambda}'),
</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>ψ</mi><mi>λ</mi></mrow></msub><mo>=</mo><msup><mi>σ</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>π</mi><mi>l</mi></msub><msub><mi>𝐮</mi><mi>l</mi></msub><mi>′</mi><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mi>l</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">
I_{\psi\lambda}=\sigma^{-2}\sum_{i=1}^m\pi_l
\mathbf{u}_l'R^{-1}\mathbf{v}_l,
</annotation></semantics></math> and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>λ</mi><mi>λ</mi></mrow></msub><mo>=</mo><msup><mi>σ</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>π</mi><mi>l</mi></msub><msub><mi>𝐯</mi><mi>l</mi></msub><mi>′</mi><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mi>l</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
I_{\lambda\lambda}=\sigma^{-2}\sum_{i=1}^m\pi_l
\mathbf{v}_l'R^{-1}\mathbf{v}_l.
</annotation></semantics></math> Again, in our case the probability of
each of the two covariate values is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo>=</mo><msub><mi>π</mi><mn>2</mn></msub><mo>=</mo><mn>1</mn><mi>/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\pi_1=\pi_2=1/2</annotation></semantics></math>;
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐮</mi><mn>1</mn></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>t</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">\mathbf{u}_1 = (t_1, \ldots, t_n)'</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐯</mi><mn>1</mn></msub><mo>=</mo><msub><mrow><mo stretchy="true" form="prefix">[</mo><mn>𝟏</mn><mspace width="0.167em"></mspace><mn>𝟎</mn><mspace width="0.167em"></mspace><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mi>n</mi><mo>×</mo><mn>3</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{v}_1 = [\mathbf{1}\, \mathbf{0}\, \mathbf{x}_i]_{n\times3}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐮</mi><mn>2</mn></msub><mo>=</mo><mn>𝟎</mn></mrow><annotation encoding="application/x-tex">\mathbf{u}_2 = \mathbf{0}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐯</mi><mn>2</mn></msub><mo>=</mo><msub><mrow><mo stretchy="true" form="prefix">[</mo><mn>𝟏</mn><mspace width="0.167em"></mspace><mn>𝟎</mn><mspace width="0.167em"></mspace><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mi>n</mi><mo>×</mo><mn>3</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{v}_2 = [\mathbf{1}\, \mathbf{0}\, \mathbf{x}_i]_{n\times3}</annotation></semantics></math>.
We have</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>I</mi><mrow><mi>ψ</mi><mi>λ</mi></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msup><mi>σ</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup><mi>/</mi><mn>2</mn><msub><mi>𝐮</mi><mn>1</mn></msub><mi>′</mi><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>I</mi><mrow><mi>λ</mi><mi>λ</mi></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msup><mi>σ</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup><mi>/</mi><mn>2</mn><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝐯</mi><mn>1</mn></msub><mi>′</mi><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mn>1</mn></msub><mo>+</mo><msub><mi>𝐯</mi><mn>2</mn></msub><mi>′</mi><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mn>1</mn><mi>/</mi><mn>2</mn><mi>X</mi><mo stretchy="false" form="postfix">]</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>I</mi><mrow><mi>ψ</mi><mi>λ</mi></mrow></msub><msubsup><mi>I</mi><mrow><mi>λ</mi><mi>λ</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msubsup></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mi>𝐮</mi><mn>1</mn></msub><mi>′</mi><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mn>1</mn></msub><msup><mi>X</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>I</mi><mrow><mi>λ</mi><mi>λ</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>I</mi><mrow><mi>ψ</mi><mi>λ</mi></mrow></msub><mi>′</mi></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msup><mi>X</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mn>1</mn></msub><mi>′</mi><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐮</mi><mn>1</mn></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{eqnarray*}
I_{\psi\lambda}&amp; = &amp; \sigma^{-2}/2\mathbf{u}_1'R^{-1}\mathbf{v}_1\\
I_{\lambda\lambda}&amp; = &amp; \sigma^{-2}/2[\mathbf{v}_1'R^{-1}\mathbf{v}_1 + \mathbf{v}_2'R^{-1}\mathbf{v}_2]=1/2X]\\
I_{\psi\lambda}I_{\lambda\lambda}^{-1} &amp; = &amp; \mathbf{u}_1'R^{-1}\mathbf{v}_1X^{-1}\\
I_{\lambda\lambda}^{-1}I_{\psi\lambda}' &amp; = &amp; X^{-1}\mathbf{v}_1'R^{-1}\mathbf{u}_1
\end{eqnarray*}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mover><mi>Σ</mi><mo accent="true">̃</mo></mover><mn>1</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msup><mi>σ</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup><mi>/</mi><mn>2</mn><mo stretchy="false" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐮</mi><mn>1</mn></msub><mo>−</mo><msub><mi>𝐮</mi><mn>1</mn></msub><mi>′</mi><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mn>1</mn></msub><msup><mi>X</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mn>1</mn></msub><mi>′</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐮</mi><mn>1</mn></msub><mo>−</mo><msub><mi>𝐯</mi><mn>1</mn></msub><msup><mi>X</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mn>1</mn></msub><mi>′</mi><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐮</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="left" style="text-align: left"><mo>+</mo><msub><mi>𝐮</mi><mn>1</mn></msub><mi>′</mi><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mn>1</mn></msub><msup><mi>X</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mn>2</mn></msub><mi>′</mi><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mn>2</mn></msub><msup><mi>X</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mn>1</mn></msub><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐮</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msup><mi>σ</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup><mi>/</mi><mn>2</mn><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝐮</mi><mn>1</mn></msub><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>𝐮</mi><mo>−</mo><msub><mi>𝐮</mi><mn>1</mn></msub><mi>′</mi><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mn>1</mn></msub><msup><mi>X</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐯</mi><mn>1</mn></msub><mi>′</mi><msup><mi>R</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐮</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{eqnarray*}
\tilde\Sigma_1 &amp; = &amp; \sigma^{-2}/2
[(\mathbf{u}_1-\mathbf{u}_1'R^{-1}\mathbf{v}_1X^{-1}\mathbf{v}_1')
R^{-1}
(\mathbf{u}_1-\mathbf{v}_1X^{-1}\mathbf{v}_1'R^{-1}\mathbf{u}_1)\\
&amp; &amp; +  \mathbf{u}_1'R^{-1}\mathbf{v}_1X^{-1}\mathbf{v}_2'R^{-1}\mathbf{v}_2X^{-1}\mathbf{v}_1R^{-1}\mathbf{u}_1\\
&amp; = &amp; 
\sigma^{-2}/2[\mathbf{u}_1R^{-1}\mathbf{u}- \mathbf{u}_1'R^{-1}\mathbf{v}_1X^{-1}\mathbf{v}_1'R^{-1}\mathbf{u}_1]
\end{eqnarray*}</annotation></semantics></math> Applying this to our
working example:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">X</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">v</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/solve-methods.html" class="external-link">solve</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="va">v</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">+</span> </span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">v</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/solve-methods.html" class="external-link">solve</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="va">v</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span></span>
<span></span>
<span><span class="va">Sigma1</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">u</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/solve-methods.html" class="external-link">solve</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="va">t</span> <span class="op">-</span> </span>
<span>           <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">u</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/solve-methods.html" class="external-link">solve</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="va">v</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/solve-methods.html" class="external-link">solve</a></span><span class="op">(</span><span class="va">X</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">v</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/solve-methods.html" class="external-link">solve</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span><span class="va">t</span><span class="op">)</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">qnorm</a></span><span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="fl">0.05</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">qnorm</a></span><span class="op">(</span><span class="fl">0.80</span><span class="op">)</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">/</span><span class="op">(</span><span class="va">Sigma1</span><span class="op">*</span><span class="op">(</span><span class="fl">1.5</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">/</span><span class="fl">2</span></span></code></pre></div>
<pre><code>         [,1]
[1,] 207.3101</code></pre>
<!-- ## Example: Ophthalmology -->
<!-- Suppose we are planning a study to test the reproducibility of a non-invasive diagnostic imaging tool, spectral domain optical coherence tomography (OCT), for children with retinal pathology. OCT produces a measure of cortical thickness in the left and right eye. We consider modeling the linear association the cortical thickness as measured by the first OCT, $X$, and the second $Y$, as: -->
<!-- \[ -->
<!-- Y_{ij} = \beta_0 + \beta_1X_{ij} + \alpha_{i} + \epsilon_{ij}^* -->
<!-- \] -->
<!-- for individual $i=1,\ldots,N$, and eye $j=1,2$. The parameter of interest is $\psi=\beta_1$ and the nuisance parameter is $\beta_0$. The covariates are distributed as $\x_{i}=(1,1)'$, and $\mathbf{z}_{i}=(z_1,z_2)\sim N(\mathbf{0},\Sigma)$ -->
<!-- ```{r echo=TRUE} -->
<!-- n=2 -->
<!-- B=10000 -->
<!-- rho = 0.5 -->
<!-- Sigma = matrix(c(1,rho,rho,1),nrow=2) # variance/covariance matrix for left/right obs -->
<!-- u = v = vector("list",B) -->
<!-- for(i in 1:B) u[[i]] = rep(1,2) -->
<!-- vv = rmvnorm(B, sigma = Sigma) -->
<!-- for(i in 1:B) v[[i]] = vv[i,] -->
<!-- liu.liang.linear.power(d=0.1, u=u, v=v, R=Sigma, sig.level=0.05/2) -->
<!-- liu.liang.linear.power(d=0.25, u=u, v=v, R=Sigma, sig.level=0.05/2) -->
<!-- liu.liang.linear.power(d=0.5, u=u, v=v, R=Sigma, sig.level=0.05/2) -->
<!-- liu.liang.linear.power(d=0.75, u=u, v=v, R=Sigma, sig.level=0.05/2) -->
<!-- ``` -->
<!-- Simulated power: -->
<!-- ```{r echo=FALSE} -->
<!-- library(nlme) -->
<!-- B=10000 -->
<!-- n = 20 -->
<!-- sim = rep(0,B) -->
<!-- d = 0.5 -->
<!-- for(i in 1:B){ -->
<!-- X = rmvnorm(n, sigma = Sigma) -->
<!-- e = rmvnorm(n, sigma = Sigma) -->
<!-- X = as.vector(t(X)) -->
<!-- e = as.vector(t(e)) -->
<!-- cluster = rep(1:n,rep(2,n)) -->
<!-- Y = d*X + e -->
<!-- if(summary(lme(Y~X, random = ~ 1 | cluster))$tTable["X","p-value"]<0.05) sim[i]=1 -->
<!-- } -->
<!-- sum(sim)/B -->
<!-- ``` -->
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-diggle" class="csl-entry">
Diggle, Peter, Kung-Yee Liang, and Scott L. Zeger. 1994. <em>Analysis of
Longitudinal Data</em>. Oxford; New York: Clarendon Press ; Oxford
University Press.
</div>
<div id="ref-laird" class="csl-entry">
Laird, N. M., and J. H. Ware. 1982. <span>“Random-Effects Models for
Longitudinal Data.”</span> <em>Biometrics</em> 38 (4): 963–74.
</div>
<div id="ref-liu" class="csl-entry">
Liu, G., and K. Y. Liang. 1997. <span>“Sample Size Calculations for
Studies with Correlated Observations.”</span> <em>Biometrics</em> 53
(3): 937–47.
</div>
<div id="ref-zeger" class="csl-entry">
Zeger, S. L., and K. Y. Liang. 1986. <span>“Longitudinal Data Analysis
for Discrete and Continuous Outcomes.”</span> <em>Biometrics</em> 42
(1): 121–30.
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Michael C. Donohue.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

      </footer>
</div>






  </body>
</html>
